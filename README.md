# Задачи первой лаборатной на Haskell по предмету функциональное программирование

Решения выполнены с учетом ограничения: используются только функции, доступные в основном модуле `Prelude`, который подключается автоматически, если явно не указано обратное.

## Список задач
1. [Задача 2: Проверка, является ли список палиндромом](#задача-2-проверка-является-ли-список-палиндромом)
2. [Задача 30: Задача про покупку скота](#задача-30-задача-про-покупку-скота)
3. [Задача 32: Кодирование списка с подсчетом повторяющихся элементов](#задача-32-кодирование-списка-с-подсчетом-повторяющихся-элементов)
4. [Задача 45: Найти все трёхзначные простые числа](#задача-45-найти-все-трёхзначные-простые-числа)
5. [Задача 55: Сортировка списков по частоте длин](#задача-55-сортировка-списков-по-частоте-длин)
6. [Задача 2.13: Нахождение суммы ряда с точностью ε](#задача-213-нахождение-суммы-ряда-с-точностью-ε)

---

## Задача 2: Проверка, является ли список палиндромом

### Условие:
Написать функцию, которая проверяет, является ли заданный список палиндромом (последовательность, которая читается одинаково слева направо и справа налево).

### Решение:
```
isPalindrome :: Eq a => [a] -> Bool
isPalindrome xs = xs == reverse xs
```
Функция сравнивает список с его перевёрнутой версией. Если они равны, список является палиндромом.

## Задача 30: Задача про покупку скота

### Условие:
Имеется 100 рублей. Сколько быков, коров и телят можно купить на все эти деньги, если плата за быка – 10 рублей, за корову – 5 рублей, за теленка – 0.5 рубля и надо купить 100 голов скота?

### Решение:

```
cattleProblem :: [(Int, Int, Int)]
cattleProblem = [(bulls, cows, calves) | 
    bulls <- [0..10], cows <- [0..20], calves <- [0..200], 
    bulls + cows + calves == 100, 
    10 * bulls + 5 * cows + calves / 2 == 100]
```
Функция возвращает список возможных комбинаций покупки быков, коров и телят, при которых общее количество голов скота и общая стоимость составляют 100.

## Задача 45: Найти все трёхзначные простые числа

### Условие:
Написать функцию, которая возвращает список всех трёхзначных простых чисел.

### Решение:
```
isPrime :: Int -> Bool
isPrime n = n > 1 && all (\x -> n `mod` x /= 0) [2..(floor (sqrt (fromIntegral n)))]

threeDigitPrimes :: [Int]
threeDigitPrimes = filter isPrime [100..999]
```
Функция возвращает список всех простых чисел в диапазоне от 100 до 999.

## Задача 55: Сортировка списков по частоте длин

### Условие:
Дан список из n списков. Необходимо отсортировать его по частотам длин списков: lfsort ["abc", "de", "fgh", "de", "ijkl", "mn", "o"] -> ["ijkl","o","abc","fgh","de","de","mn"]
То есть списки с одинаковой длиной должны быть сгруппированы, а затем отсортированы по частоте их длины.

### Решение:
```
-- Функция для сортировки по длине списков
sortLength :: [[a]] -> [[a]]
sortLength [] = []
sortLength (x:xs) = sortLength [y | y <- xs, length y <= length x]
                    ++ [x] ++
                    sortLength [y | y <- xs, length y > length x]

-- Группировка списка по длинам
groupLists :: Eq a => [[a]] -> [[[a]]]
groupLists [] = []
groupLists (x:xs) = let (first, rest) = span (\y -> length y == length x) xs
                    in (x:first) : groupLists rest

-- Основная функция для сортировки по частоте
lfsort :: [[a]] -> [[a]]
lfsort xs = concat $ sortLength $ groupLists $ sortLength xs
```
